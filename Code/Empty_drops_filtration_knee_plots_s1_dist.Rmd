---
title: " Knee plots coloured by UMI distribution"
author: "Maria"
date: "2024-04-25"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Libraries

```{r, libraries, echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(Matrix)
library(tibble)
library(ggplot2)
library(ggpubr)
library(grid)
library(gridExtra)
library(viridis)
library(RColorBrewer)
library(DropletUtils)
library(glue)
```
Определим функцию, которая  возвращает отсортированный по количеству UMI/CB датафрейм, полученный для суммарного количество UMI в двух(!) образцах 
```{r, warning=FALSE}
UMI_per_CB_sample_dist <- function(counts_path_s1, barcodes_path_s1, genes_path_s1, counts_path_s2, barcodes_path_s2, genes_path_s2){

  #Read files
  counts <- Matrix::readMM(counts_path_s1)
  genes <- readr::read_tsv(genes_path_s1, col_names = FALSE)
  gene_ids <- genes$X1
  cell_ids <- readr::read_tsv(barcodes_path_s1, col_names = FALSE)$X1
  
  #Assign row and colnames
  rownames(counts) <- gene_ids
  colnames(counts) <- cell_ids
  
  #Calculate UMI per cell barcode distribution
  umi_per_CB <- Matrix::colSums(counts)[Matrix::colSums(counts) > 0]
  
  #Calculate gene per cell barcode distribution
  gene_per_CB <- Matrix::colSums(counts > 0)[Matrix::colSums(counts) > 0]
  
  
  #Create sorted UMI_count DF
  DF_umi_per_CB1 <- as.data.frame(umi_per_CB) %>%
    arrange(desc(umi_per_CB)) %>%
    mutate(cb = as.numeric(rownames(as.data.frame(umi_per_CB))))
  
  #Read files
  counts <- Matrix::readMM(counts_path_s2)
  genes <- readr::read_tsv(genes_path_s2, col_names = FALSE)
  gene_ids <- genes$X1
  cell_ids <- readr::read_tsv(barcodes_path_s2, col_names = FALSE)$X1
  
  #Assign row and colnames
  rownames(counts) <- gene_ids
  colnames(counts) <- cell_ids
  
  #Calculate UMI per cell barcode distribution
  umi_per_CB <- Matrix::colSums(counts)[Matrix::colSums(counts) > 0]
  
  #Calculate gene per cell barcode distribution
  gene_per_CB <- Matrix::colSums(counts > 0)[Matrix::colSums(counts) > 0]
  
  
  #Create sorted UMI_count DF
  DF_umi_per_CB2 <- as.data.frame(umi_per_CB) %>%
    arrange(desc(umi_per_CB)) %>%
    mutate(cb = as.numeric(rownames(as.data.frame(umi_per_CB))))
  
  
  DF_umi_per_CB_s1_s2_sort <- merge(DF_umi_per_CB1, DF_umi_per_CB2, 
                               by = 'row.names', all = TRUE)

  #Replcase NA's with 0
  DF_umi_per_CB_s1_s2_sort[is.na(DF_umi_per_CB_s1_s2_sort)] <- 0
  
  #Calculate distribution
  DF_umi_per_CB_s1_s2_sort <- DF_umi_per_CB_s1_s2_sort %>%
    mutate(dist_s1 = round(umi_per_CB.x/(umi_per_CB.x + umi_per_CB.y),6)) %>%
    mutate(dist_s2 = round(umi_per_CB.y/(umi_per_CB.x + umi_per_CB.y),6))
  
  
  DF_all <- DF_umi_per_CB_s1_s2_sort %>%
    mutate(dist_s1 = round(umi_per_CB.x/(umi_per_CB.x + umi_per_CB.y),6)) %>%
    mutate(dist_s2 = round(umi_per_CB.y/(umi_per_CB.x + umi_per_CB.y),6))%>%
    mutate(umi_per_CB_total = umi_per_CB.y + umi_per_CB.x)
  DF_all_sorted <- as.data.frame(DF_all) %>%
    arrange(desc(DF_all$umi_per_CB_total))
  DF_all_sorted <- as.data.frame(DF_all_sorted) %>%
    mutate(common_CB_number = as.numeric(rownames(as.data.frame(DF_all_sorted))))

  return (DF_all_sorted)
}
```
Теперь определим фуункцию, которая будет строить knee_plot и  раскрашивать его в зависимость от того, какая доля UMI пришла в суммарный датасет из первого образца
Ппринимает на вход датафрейм,  и название графика
В df должны быть следующие колонки:
*common_CB_number* номер баркода  из суммарного для двух образцов df отсортированного по общему количеству UMI/CB
*umi_per_CB* количество UMI для этого баркода в  ДВУХ образце 1
*dist_s1*  - отношение количества UMI для этого баркода в образце 1 к количеству всех UMI для этого баркода и имя образца
```{R}
knee_plot_UMI_sample_dist <- function(df, name){
  colors <- brewer.pal(n = 11, name = "Spectral")
  knee_plot_UMI_sample_dist <- ggplot(df, aes(x = common_CB_number, y = umi_per_CB_total, colour = dist_s1*100)) +
    geom_point(size = 2) +
    labs(y = 'UMI count, log10', x = 'cell barcodes, log10', title = name) +
    theme_linedraw() +
    theme(axis.text=element_text(size=14),
          axis.title=element_text(size=16,face="bold")) +
    scale_y_log10(limits = c(100, 21000)) +
    scale_x_log10(limits = c(1, 11000)) +
    scale_colour_gradientn(colours = colors,
                           guide = guide_colorbar(title = "UMIs from Sample1, %")) 
  return (knee_plot_UMI_sample_dist)
}
```
Напишем функцию для фильтрования баркодов из сырой матрицы при помощи EmptyDrops
Принимает на вход:
*sparse_matrix* матрица,
*lower* = 100 порог отсечки,
*test.ambient* = TRUE

```{R, warning=FALSE}

filter_barcodes_with_emptyDrops <- function(sparse_matrix, lower = 100, test.ambient = TRUE) {
  emptyDrops_df = emptyDrops(sparse_matrix, lower = lower, test.ambient = test.ambient)
  emptyDrops_df$FDR[is.na(emptyDrops_df$FDR)] <- 1 # выставляю всем NA FDR единичку
  return(emptyDrops_df)
}

return_filtered_barcodes_or_indeces <- function(emptyDrops_df, fdr_threshold = 0.05, return_indeces = FALSE) {
  filtered_barcodes_indeces <- which(emptyDrops_df$FDR < fdr_threshold) #список со всеми отфильтр. баркодами
  
  if (return_indeces) {
    return(filtered_barcodes_indeces)
  }
  return(rownames(emptyDrops_df)[filtered_barcodes_indeces])
}
```
Проведем фильтрацию для каждого из двух образцов Solo1 и Solo2

Чтение данных solo1
```{R matrices,  warning=FALSE, , message=FALSE}
path_to_matrix <- "C:/Maria/IB/metrics/Data/Solo.out_1/Gene/raw/matrix.mtx.gz"
path_to_barcodes <- "C:/Maria/IB/metrics/Data/Solo.out_1/Gene/raw/barcodes.tsv.gz"
matrix_1_raw <- readMM(path_to_matrix)
cell_ids <- readr::read_tsv(path_to_barcodes, col_names = FALSE)$X1
colnames(matrix_1_raw) <- cell_ids
```

Запуск emptyDrops solo1 и получение списка выбранных баркодов
```{R}
emptyDrops_df_1 <- filter_barcodes_with_emptyDrops(matrix_1_raw)
filtered_barcodes1 <- return_filtered_barcodes_or_indeces(emptyDrops_df_1, fdr_threshold = 0.05) #список со всеми отфильтр. баркодами
```

```{R, barcode_ranks}
sce_1 <- read10xCounts('C:/Maria/IB/metrics/Data/Solo.out_1/Gene/raw', type = 'sparse')
br.out_1 <- barcodeRanks(assays(sce_1)$counts)
knee_solo1 <-  br.out_1@metadata$knee
inflection_solo1 <-  br.out_1@metadata$inflection
print('Number of UMIs for  knee_point')
print(knee_solo1)
print('Number of UMIs for inflection_point')
print(inflection_solo1)

```
Чтение данных solo2
```{R, warning=FALSE, message=FALSE}
path_to_matrix <- "C:/Maria/IB/metrics/Data/Solo.out_2/Gene/raw/matrix.mtx.gz"
path_to_barcodes <- "C:/Maria/IB/metrics/Data/Solo.out_2/Gene/raw/barcodes.tsv.gz"
matrix_2_raw <- readMM(path_to_matrix)
cell_ids <- readr::read_tsv(path_to_barcodes, col_names = FALSE)$X1
colnames(matrix_2_raw) <- cell_ids
```

Запуск emptyDrops solo2 и  и получение списка выбранных баркодов

```{R}
emptyDrops_df_2 <- filter_barcodes_with_emptyDrops(matrix_2_raw)
#emptyDrops_df_2
filtered_barcodes2 <- return_filtered_barcodes_or_indeces(emptyDrops_df_2, fdr_threshold = 0.05) #список со всеми отфильтр. баркодами

```

```{R, barcode_ranks, solo2}
sce_2 <- read10xCounts('C:/Maria/IB/metrics/Data/Solo.out_2/Gene/raw', type = 'sparse')
br.out_2 <- barcodeRanks(assays(sce_2)$counts)
knee_solo2 <-  br.out_2@metadata$knee
inflection_solo2 <-  br.out_2@metadata$inflection
print('Number of UMIs for  knee_point')
print(knee_solo2)
print('Number of UMIs for inflection_point')
print(inflection_solo2)

```
Получили около 4000 СВ отобранный для Solo1 (из 55501), и меньше тысячи для Solo2 (из 37628). Отбирали n>100, fdr_threshold = 0.05
посмотрим, какие из них общие, а сколько получается суммарно для двух образцов

```{R}
filtered_barcodes_common <- intersect(filtered_barcodes1, filtered_barcodes2)
print('common:')
print(length(filtered_barcodes_common))
print('from 1 or 2:')
filtered_barcodes <- unique(c(filtered_barcodes1, filtered_barcodes2))
print(length(filtered_barcodes))
```
видим, что, в одном из вариантов расчета,  731 баркод (из 4170 и 960) был отобран из каждого из двух образцов, суммарно для двух образцов выбрано разных 4399 (данные меняются, так как есть этап рандомайза из-за использования метода Монте-Карло)

Теперь получим датафрейм для двух образцов Solo1 и Solo2, в котором будут посчитано сумманое количество UMI и доля, пришедшая из каждого образца
```{R, warning=FALSE, message=FALSE}
#-----------------------------------------------------Solo1_raw

counts_path_s1 <- ("C:/Maria/IB/metrics/Data/Solo.out_1/Gene/raw/matrix.mtx.gz")
genes_path_s1 <- ("C:/Maria/IB/metrics/Data/Solo.out_1/Gene/raw/features.tsv.gz")
barcodes_path_s1 <- ("C:/Maria/IB/metrics/Data/Solo.out_1/Gene/raw/barcodes.tsv.gz")

#-----------------------------------------------------Solo2_raw
counts_path_s2 <- ("C:/Maria/IB/metrics/Data/Solo.out_2/Gene/raw/matrix.mtx.gz")
genes_path_s2 <- ("C:/Maria/IB/metrics/Data/Solo.out_2/Gene/raw/features.tsv.gz")
barcodes_path_s2 <- ("C:/Maria/IB/metrics/Data/Solo.out_2/Gene/raw/barcodes.tsv.gz")

dfGR <- UMI_per_CB_sample_dist(counts_path_s1, barcodes_path_s1, genes_path_s1, counts_path_s2, barcodes_path_s2, genes_path_s2)
```
Найдем в суммарных данных для Solo1 и Solo2 те CB, которые были выбраны ED для Solo1 и Solo2, и те, которые были забракованы
Получается  примерно 4350 СВ отобраны по двум образцам, при этом 3480 содержат > 100 UMI, но не были выбраны ED (тут 
```{R, message = FALSE, warnings = FALSE}
ED_yes <-  subset(dfGR, Row.names %in% filtered_barcodes)
all_100 <-  subset(dfGR, dfGR$umi_per_CB.x > 100 | dfGR$umi_per_CB.y > 100)
ED_no <-  subset(all_100, !(Row.names %in% filtered_barcodes))
# mixed for better visualisation
ED_yes <- ED_yes[sample(nrow(ED_yes)), ]
ED_no <- ED_no[sample(nrow(ED_no)), ]
all_100 <- all_100[sample(nrow(all_100)), ]

```
Create knee-plots coloured by proportion of UMIs coming from sample Solo1 for selected/not selected by ED and all barcodes

```{R, knee_plots, warning = FALSE}
yes <- knee_plot_UMI_sample_dist(ED_yes, 'Selected by ED, (ED_yes)') 

no <-  knee_plot_UMI_sample_dist(ED_no,'Not selected by ED (ED_no)') 

all <- knee_plot_UMI_sample_dist(all_100, 'all, nUMIs > 100') 


combined_plot_3 <- (yes |  no | all) + 
  plot_annotation(
    theme = theme(plot.title = element_text(hjust = 0.5)) 
  )
combined_plot_3

file_path <- "knee_plots_all_yes_no.png"
ggsave(file = file_path, plot = combined_plot_3, width = 24, height = 7, units = "in", dpi = 300)
```
